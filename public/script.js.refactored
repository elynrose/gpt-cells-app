/**
 * GPT Cells Application - Frontend
 * 
 * A client-side spreadsheet application with AI-powered content generation
 * supporting text, image, and audio generation with persistent storage.
 * 
 * @fileoverview Main application script for GPT Cells
 * @version 1.0.0
 * @author GPT Cells Team
 */

'use strict';

// ============================================================================
// SECTION 1: GLOBAL STATE MANAGEMENT
// ============================================================================

/**
 * Application state object containing all global state variables
 * @namespace AppState
 */
const AppState = {
  // Authentication state
  currentUser: null,
  isAuthenticated: false,
  isAdmin: false,

  // Project and sheet management
  currentProjectId: null,
  currentProject: null,
  projects: [],
  currentSheetIndex: 0,
  sheets: [{
    id: `default-sheet-${Date.now()}`,
    name: 'Sheet1',
    cells: {},
    numRows: 10,
    numCols: 10,
    columnNames: {},
    cardPositions: {}
  }],

  // Current sheet reference
  get currentSheet() {
    return this.sheets[this.currentSheetIndex] || this.sheets[0];
  },

  // Available AI models
  availableModels: [],

  // UI state
  currentModalCellId: null,
  currentEditingCell: null,

  // Timers and debouncing
  autosaveTimers: {},
  cellIntervalTimers: {},
  cardPositionsSaveTimer: null,
  connectionUpdateTimers: {}
};

// Legacy global variables for backward compatibility
let currentUser = null;
let isAuthenticated = false;
let isAdmin = false;
let currentProjectId = null;
let currentProject = null;
let projects = [];
let currentSheetIndex = 0;
let sheets = AppState.sheets;
let currentSheet = sheets[currentSheetIndex];
let cells = currentSheet.cells;
let numRows = currentSheet.numRows;
let numCols = currentSheet.numCols;
let availableModels = [];
let currentModalCellId = null;
let currentEditingCell = null;
const autosaveTimers = {};
const cellIntervalTimers = {};
let cardPositionsSaveTimer = null;

// ============================================================================
// SECTION 2: CONSTANTS AND CONFIGURATION
// ============================================================================

/**
 * Excel formula functions supported by the application
 * @constant {Object<string, Function>}
 */
const EXCEL_FUNCTIONS = {
  SUM: (...args) => args.reduce((sum, val) => sum + (parseFloat(val) || 0), 0),
  AVERAGE: (...args) => {
    const nums = args.filter(val => !isNaN(parseFloat(val)));
    return nums.length > 0 
      ? nums.reduce((sum, val) => sum + parseFloat(val), 0) / nums.length 
      : 0;
  },
  COUNT: (...args) => args.filter(val => !isNaN(parseFloat(val))).length,
  MAX: (...args) => Math.max(...args.map(val => parseFloat(val) || -Infinity)),
  MIN: (...args) => Math.min(...args.map(val => parseFloat(val) || Infinity)),
  IF: (condition, trueVal, falseVal) => condition ? trueVal : falseVal,
  CONCATENATE: (...args) => args.join(''),
  LEN: (text) => String(text).length,
  UPPER: (text) => String(text).toUpperCase(),
  LOWER: (text) => String(text).toLowerCase(),
  TRIM: (text) => String(text).trim(),
  ROUND: (number, decimals = 0) => 
    Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals),
  ABS: (number) => Math.abs(number),
  SQRT: (number) => Math.sqrt(number),
  POWER: (base, exponent) => Math.pow(base, exponent)
};

/**
 * Default configuration values
 * @constant {Object}
 */
const DEFAULT_CONFIG = {
  MODEL: 'gpt-3.5-turbo',
  TEMPERATURE: 0.7,
  NUM_ROWS: 10,
  NUM_COLS: 10,
  AUTOSAVE_DELAY: 1000,
  CONNECTION_UPDATE_DELAY: 200,
  CARD_POSITION_SAVE_DELAY: 500
};

// ============================================================================
// SECTION 3: UTILITY FUNCTIONS
// ============================================================================

/**
 * Utility functions for common operations
 * @namespace Utils
 */
const Utils = {
  /**
   * Debounce function to limit how often a function can be called
   * @param {Function} func - Function to debounce
   * @param {number} wait - Wait time in milliseconds
   * @param {string} key - Unique key for the debounce timer
   * @returns {void}
   */
  debounce(func, wait, key) {
    const debounceMap = new Map();
    if (debounceMap.has(key)) {
      clearTimeout(debounceMap.get(key));
    }
    const timeout = setTimeout(() => {
      func();
      debounceMap.delete(key);
    }, wait);
    debounceMap.set(key, timeout);
  },

  /**
   * Safely parse a number, returning 0 if invalid
   * @param {*} value - Value to parse
   * @returns {number}
   */
  safeParseFloat(value) {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? 0 : parsed;
  },

  /**
   * Check if a value is empty or whitespace
   * @param {*} value - Value to check
   * @returns {boolean}
   */
  isEmpty(value) {
    return !value || (typeof value === 'string' && value.trim() === '');
  }
};

// ============================================================================
// SECTION 4: CELL REFERENCE PARSING
// ============================================================================

/**
 * Parse a cell reference (e.g., "A1", "B2") and return its value
 * @param {string} ref - Cell reference in format "A1", "B2", etc.
 * @returns {string|number} The cell's output value, or 0 if not found
 */
function parseCellReference(ref) {
  const match = ref.match(/^([A-Z]+)(\d+)$/);
  if (!match) return 0;
  
  const col = match[1];
  const row = parseInt(match[2]) - 1; // Convert to 0-based
  
  // Convert column letter to number (A=0, B=1, etc.)
  let colNum = 0;
  for (let i = 0; i < col.length; i++) {
    colNum = colNum * 26 + (col.charCodeAt(i) - 64);
  }
  colNum -= 1; // Convert to 0-based
  
  const cellId = String.fromCharCode(65 + colNum) + (row + 1);
  const cell = currentSheet.cells[cellId];
  
  if (cell && cell.output) {
    const value = cell.output.trim();
    return isNaN(parseFloat(value)) ? value : parseFloat(value);
  }
  
  return 0;
}

/**
 * Parse a cell range (e.g., "A1:B2") and return array of values
 * @param {string} range - Cell range in format "A1:B2"
 * @returns {Array<string|number>} Array of cell values
 */
function parseCellRange(range) {
  const [start, end] = range.split(':');
  const startMatch = start.match(/^([A-Z]+)(\d+)$/);
  const endMatch = end.match(/^([A-Z]+)(\d+)$/);
  
  if (!startMatch || !endMatch) return [];
  
  const startCol = startMatch[1];
  const startRow = parseInt(startMatch[2]);
  const endCol = endMatch[1];
  const endRow = parseInt(endMatch[2]);
  
  const values = [];
  
  // Convert column letters to numbers
  const startColNum = startCol.charCodeAt(0) - 65;
  const endColNum = endCol.charCodeAt(0) - 65;
  
  for (let row = startRow; row <= endRow; row++) {
    for (let col = startColNum; col <= endColNum; col++) {
      const cellId = String.fromCharCode(65 + col) + row;
      const cell = currentSheet.cells[cellId];
      if (cell && cell.output) {
        const value = cell.output.trim();
        values.push(isNaN(parseFloat(value)) ? value : parseFloat(value));
      } else {
        values.push(0);
      }
    }
  }
  
  return values;
}

/**
 * Parse and evaluate an Excel formula
 * @param {string} formula - Formula string starting with "="
 * @returns {string|number} Evaluated result or "#ERROR" if parsing fails
 */
function parseFormula(formula) {
  try {
    // Remove the = sign
    let expression = formula.substring(1);
    
    // Handle cell references (A1, B2, etc.)
    expression = expression.replace(/([A-Z]+\d+)/g, (match) => {
      return parseCellReference(match);
    });
    
    // Handle cell ranges (A1:B2)
    expression = expression.replace(/([A-Z]+\d+:[A-Z]+\d+)/g, (match) => {
      const values = parseCellRange(match);
      return `[${values.join(',')}]`;
    });
    
    // Handle Excel functions
    for (const [funcName, func] of Object.entries(EXCEL_FUNCTIONS)) {
      const regex = new RegExp(`${funcName}\\(([^)]+)\\)`, 'gi');
      expression = expression.replace(regex, (match, args) => {
        const argValues = args.split(',').map(arg => {
          arg = arg.trim();
          // Handle array notation from ranges
          if (arg.startsWith('[') && arg.endsWith(']')) {
            return arg.slice(1, -1).split(',').map(v => parseFloat(v.trim()) || 0);
          }
          return parseFloat(arg) || arg;
        });
        
        // Flatten arrays
        const flatArgs = argValues.reduce((acc, val) => {
          return acc.concat(Array.isArray(val) ? val : [val]);
        }, []);
        
        return func(...flatArgs);
      });
    }
    
    // Evaluate the final expression
    // Note: Using eval is generally unsafe, but necessary for formula evaluation
    // In production, consider using a safer expression evaluator
    return eval(expression);
  } catch (error) {
    console.error('Formula parsing error:', error);
    return '#ERROR';
  }
}

/**
 * Check if a cell value is a formula
 * @param {*} value - Value to check
 * @returns {boolean} True if value is a formula
 */
function isFormula(value) {
  return typeof value === 'string' && value.startsWith('=');
}

// ============================================================================
// SECTION 5: DEPENDENCY PARSING
// ============================================================================

/**
 * Parse dependencies from a prompt string
 * Dependencies are denoted by {{ID}} where ID is another cell identifier
 * 
 * Supports multiple reference formats:
 * - {{A1}} - just the cell output
 * - {{prompt:A1}} - the cell's prompt
 * - {{output:A1}} - the cell's output (explicit)
 * - {{A1-1}} - first generation of cell A1
 * - {{A1-2}} - second generation of cell A1
 * - {{A1:1-3}} - generations 1 to 3 of cell A1
 * - {{A1:2}} - just generation 2 of cell A1
 * - {{Sheet2!A1}} - cross-sheet reference
 * - {{prompt:Sheet2!A1}} - cross-sheet prompt
 * 
 * @param {string} prompt - The prompt string to parse
 * @returns {Array<string>} List of referenced cell IDs
 */
function parseDependencies(prompt) {
  if (!prompt || typeof prompt !== 'string') return [];
  
  const regex = /\{\{([^}]+)\}\}/g;
  const deps = [];
  let match;
  
  while ((match = regex.exec(prompt)) !== null) {
    deps.push(match[1]);
  }
  
  return deps;
}

/**
 * Extract clean cell ID from a dependency reference
 * Handles formats like "A1", "prompt:A1", "output:A1", "A1-1", etc.
 * 
 * @param {string} depRef - Dependency reference string
 * @returns {string} Clean cell ID (e.g., "A1")
 */
function extractCellIdFromDependency(depRef) {
  if (!depRef) return '';
  
  let cellId = depRef;
  
  // Skip cross-sheet references
  if (cellId.includes('!')) {
    return '';
  }
  
  // Remove prefixes like "prompt:", "output:"
  if (cellId.includes(':')) {
    const parts = cellId.split(':');
    cellId = parts[parts.length - 1];
  }
  
  // Remove generation suffixes like "-1", ":1-3", ":2"
  if (cellId.includes('-')) {
    cellId = cellId.split('-')[0];
  }
  
  // Remove any remaining colons (for generation ranges)
  cellId = cellId.split(':')[0];
  
  return cellId.trim();
}

// ============================================================================
// SECTION 6: USER FEEDBACK AND NOTIFICATIONS
// ============================================================================

/**
 * Display an error message to the user
 * @param {string} message - Error message to display
 * @param {number} duration - Duration in milliseconds (default: 5000)
 * @returns {void}
 */
function showError(message, duration = 5000) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-message';
  errorDiv.textContent = message;
  errorDiv.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #dc3545;
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    font-size: 14px;
    max-width: 400px;
  `;
  
  document.body.appendChild(errorDiv);
  
  setTimeout(() => {
    errorDiv.style.opacity = '0';
    errorDiv.style.transition = 'opacity 0.3s';
    setTimeout(() => errorDiv.remove(), 300);
  }, duration);
}

/**
 * Display a success message to the user
 * @param {string} message - Success message to display
 * @param {number} duration - Duration in milliseconds (default: 3000)
 * @returns {void}
 */
function showSuccess(message, duration = 3000) {
  const successDiv = document.createElement('div');
  successDiv.className = 'success-message';
  successDiv.textContent = message;
  successDiv.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #28a745;
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    font-size: 14px;
    max-width: 400px;
  `;
  
  document.body.appendChild(successDiv);
  
  setTimeout(() => {
    successDiv.style.opacity = '0';
    successDiv.style.transition = 'opacity 0.3s';
    setTimeout(() => successDiv.remove(), 300);
  }, duration);
}

// ============================================================================
// NOTE: This is a partial refactoring showing the structure.
// The full file would continue with all remaining functions organized
// into logical sections with proper JSDoc comments.
// ============================================================================

// Continue with remaining sections:
// - Model Management
// - Cell Operations
// - Card Management
// - Connection Management
// - Database Operations
// - UI Rendering
// - Event Handlers
// - Initialization


